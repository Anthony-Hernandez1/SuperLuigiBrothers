MAIN.CPP
/***********************************
*       square with classes         *
*   does not work as of yet         *
************************************/

#include <iostream>
#include <cmath>
#include "SDL_Plotter.h"
#include "Player.h"
#include "floor.h"
#include "actualFloor.h"
using namespace std;


int main(int argc, char ** argv)
{
    const int windowHeight = 600;
    const int windowWidth = 1000;
    SDL_Plotter g(windowHeight,windowWidth);   // makes width and height of play window

     // dot that moves around
    Player mario;
    Floor f;
    actualFloor aF;
    bool stopped = false;
    // set wall
    SDL_Rect wall;
    wall.x = 300;
    wall.y = 40;
    wall.w = 40;
    wall.h = 400;

    int jumpPosition = 0;
     while (!g.getQuit())
    {
        // draw background
        for (int col = 0; col < windowWidth; ++col)
        {
            for (int row = 0; row < windowHeight; row++)
            {
                g.plotPixel(col,row, 0,0,0);
            }
        }


        //input
        if(g.getKey() == DOWN_ARROW)    // allows you to move
        {
            mario.movePlayer(0,1);   // moves character down 1 (y access positive)
        }
        else if (g.getKey() == UP_ARROW)
        {
            mario.movePlayer(0,-1);

        }
        else if (g.getKey() == RIGHT_ARROW)
        {
            mario.movePlayer(1,0);
        }
        else if (g.getKey() == LEFT_ARROW)
        {
            mario.movePlayer(-1,0);
        }

        if(g.kbhit()){
            g.getKey();
        }
        g.clear();
        mario.draw(g);

/****************************
*       platforms     *
****************************/

//platform1
       int pX = 0;
       int pY = 300;
        f.draw(g,pX,pY);

        pX = 600;
        pY = 300;
        f.draw(g,pX,pY);

        pX = 0;
        pY = 150;
        f.draw(g,pX,pY);

        pX = 600;
        pY = 150;
        f.draw(g,pX,pY);

        pX = 0;
        pY = 560;
        aF.draw(g,pX,pY);
        g.update();
    }
}

/*****************************************
*            square moving no class   *
*       works
*****************************************/
/*
#include <iostream>
#include <cmath>
#include <fstream>
#include "floor.h"
#include "SDL_Plotter.h"

using namespace std;

struct pixel
{
    int r;
    int g;
    int b;
};
const int ROW = 36;
const int COL = 21;
int main(int argc, char ** argv)
{
    const int windowHeight = 600;
    const int windowWidth = // draw background
        for (int col = 0; col < windowWidth; ++col)
        {
            for (int row = 0; row < windowHeight; row++)
            {
                g.plotPixel(col,row, 0,0,0);
            }
        }1000;
    SDL_Plotter g(windowHeight,windowWidth); // makes width and height of play window
    Floor f;
    /************************
    *       platform read in from file       *
    ************************/
    /*
    int x, y,xd,yd; // starts at top right corner
    ifstream infile;

    infile.open("floor.txt");

    pixel pic[ROW][COL];
// when reading from file, outer loop is rows
// inner column is columns
    for (int i = 0; i < ROW; i++)
    {
        for (int k = 0; k < COL; k++)
        {
            infile >> pic[i][k].r;
            infile >> pic[i][k].g;
            infile >> pic[i][k].b;
        }
    }

    while (!g.getQuit())
    {
        for (xd = 0; xd < ROW; xd++)
        {
            for (yd = 0; yd < COL; yd++)
            {
                g.plotPixel(y+yd,x+xd,pic[xd][yd].r,pic[xd][yd].g,pic[xd][yd].b);
            }
        }
    }



    bool stopped = false;

    int width = 74;
    int height = 22;
    int posX = 200;
    int posY = 200;

    while (!g.getQuit())
    {
        //input
        if(g.getKey() == DOWN_ARROW)    // allows you to move
        {
            posY = min(posY + 1, windowHeight - height);    // ensures you do not go off screen
        }
        else if (g.getKey() == UP_ARROW)
        {
            posY = max(posY - 1,0);
        }
        else if (g.getKey() == RIGHT_ARROW)
        {
            posX = min(posX + 1, windowWidth - width);
        }
        else if (g.getKey() == LEFT_ARROW)
        {
            posX = max(posX - 1, 0);
        }


        // draw background
        for (int col = 0; col < windowWidth; ++col)
        {
            for (int row = 0; row < windowHeight; row++)
            {
                g.plotPixel(col,row, 0,0,0);
            }
        }
// draw square
        for (int col = posX; col < width + posX; col++)   // goes through all columns
        {
            for (int row = posY; row < height + posY; ++row)
            {
                g.plotPixel(col,row, 23,10,204);
            }
        }
        if(g.kbhit()){
            g.getKey();
        }*/
/****************************
*       platforms     *
****************************/

//platform1

     /*   int w = 400;
        int h = 40;
        int pX = 0;
        int pY = 300;
        for (int col = pX; col < w + pX; col++)   // goes through all columns
            {
                for (int row = pY; row < h + pY; ++row)
                {
                    g.plotPixel(col,row, 0,255,0);
                }
            }
//platform 2
        int w2 = 400;
        int h2 = 40;
        int pX2 = 600;
        int pY2 = 300;
        for (int col = pX2; col < w2 + pX2; col++)   // goes through all columns
            {
                for (int row = pY2; row < h2 + pY2; ++row)
                {
                    g.plotPixel(col,row, 0,255,0);
                }
            }
//platform3
        int w3 = 400;
        int h3 = 40;
        int pX3 = 0;
        int pY3 = 150;
        for (int col = pX3; col < w3 + pX3; col++)   // goes through all columns
            {
                for (int row = pY3; row < h3 + pY3; ++row)
                {
                    g.plotPixel(col,row, 0,255,0);
                }
            }
//platform5
        int w5 = 400;
        int h5 = 40;
        int pX5 = 600;
        int pY5 = 150;
        for (int col = pX5; col < w5 + pX5; col++)   // goes through all columns
            {
                for (int row = pY5; row < h5 + pY5; ++row)
                {
                    g.plotPixel(col,row, 0,255,0);
                }
            }
       int pX = 400;
       int pY = 150;
        f.draw(g,pX,pY);


        g.update();
    }


}
/****************************
*       secondCharacter     *
****************************/
/*    int w = 10;
    int h = 10;
    int pX = 100;
    int pY = 100;
    // input for second character
    while (!g.getQuit())
    {
         // draw second square
        for (int col = pX; col < w + pX; col++)   // goes through all columns
        {
            for (int row = pY; row < h + pY; ++row)
            {
                g.plotPixel(col,row, 0,255,0);
            }
        }

        //input
        if(g.getKey() == 'S')    // allows you to move
        {
            pY = min(pY + 1, windowHeight - h);    // ensures you do not go off screen
        }
        else if (g.getKey() == 'W')
        {
            pY = max(pY - 1,0);
        }
        else if (g.getKey() == 'D')
        {
            pY = min(pY + 1, windowWidth - w);
        }
        else if (g.getKey() == 'A')
        {
            pX = max(pX - 1, 0);
        }

    // lets draw a pic

/*        if(g.getMouseClick(x,y))
        {
            //nothing
        }
        if(g.kbhit()){
            g.getKey();
        }



        g.update();
    }*/


/**************************************
*           Aars' Example             *
**************************************/
/*
#include <iostream>
#include <fstream>
#include "SDL_Plotter.h"

using namespace std;

struct pixel
{
    int r;
    int g;
    int b;
};

const int ROW = 28;
const int COL = 20;
int main(int argc, char ** argv)
{

    SDL_Plotter g(1000,1000);
    int x = 500,y=500, xd, yd; // starts in middle
    int R = 0,G = 200,B = 0;

    ifstream infile;

    infile.open("foo.txt");

    pixel pic[ROW][COL];
// when reading from file, outer loop is rows
// inner column is columns
    for (int i = 0; i < ROW; i++)
    {
        for (int k = 0; k< COL; k++)
        {
            infile >> pic[i][k].r;
            infile >> pic[i][k].g;
            infile >> pic[i][k].b;

        }
    }
    while (!g.getQuit())
    {
			for(xd = 0; xd < ROW; xd++ ){
				for(yd = 0; yd < COL; yd++ ){
                        g.plotPixel(y+yd,x+xd,pic[xd][yd].r,pic[xd][yd].g,pic[xd][yd].b);
				}
			}
		}

		if(g.kbhit()){
			g.getKey();
		}

		if(g.getMouseClick(x,y)){
			//nothing
		}

		g.update();

}
*/
//000 000 000 111 111 111
// r   g   b   r   g   b




FLOOR.H

#ifndef FLOOR_H
#define FLOOR_H
#include <iostream>
#include <algorithm>
#include "SDL_Plotter.h"
using namespace std;


class Floor
{
private:
// what makes object up
    int width = 400;
    int height = 40;
    int posX = 600;
    int posY = 150;

public:
// what object does

    void draw(SDL_Plotter & g, int posX,int posY)
    {
        for (int col = posX; col < width + posX; col++)   // goes through all columns
        {
            for (int row = posY; row < height + posY; ++row)
            {
                g.plotPixel(col,row, 0,255,0);
            }
        }
    }
};
#endif // SDL_PLOTTER_H_


PLAYER.H
#ifndef PLAYER_H
#define PLAYER_H
#include <iostream>
#include <algorithm>
#include "SDL_Plotter.h"
using namespace std;


const int windowHeight = 600;
const int windowWidth = 1000;

class Player
{
private:
// what makes object up
    int width = 74;
    int height = 22;
    int posX = 200;
    int posY = 200;

public:
// what object does

    void movePlayer(int xOffset, int yOffset)   // allows you to move
    {
        posX = min(max(posX + xOffset, 0), windowWidth - width);   // allows object to move, max width, does not allow player to go off screen
        posY = min(max(posY + yOffset, 0), windowHeight - height);
    }
    void draw(SDL_Plotter & g)
    {
        for (int col = posX; col < width + posX; col++)   // goes through all columns
        {
            for (int row = posY; row < height + posY; ++row)
            {
                g.plotPixel(col,row, 23,10,204);
            }
        }
    }


};
#endif // SDL_PLOTTER_H_
